package models

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

// DBCredentials hold credentials for database
type DBCredentials struct {
	Server       string
	Database     string
	UserID       string
	Password     string
	UseFederated bool
}

// Env instance variables
type Env struct {
	Context          string
	APIEnvironment   string
	ClusterName      string
	DNSZone          string
	UseLocalRadixApi bool
	UseProfiler      bool
	DbCredentials    *DBCredentials
	Cluster          string
	OidcAudience     string
	OidcIssuer       string
}

// NewEnv Constructor
func NewEnv(ctx context.Context) (*Env, context.Context, error) {
	var (
		errs                []error
		context             = os.Getenv("RADIX_CLUSTER_TYPE")
		apiEnv              = os.Getenv("RADIX_ENVIRONMENT")
		clusterName         = os.Getenv("RADIX_CLUSTERNAME")
		dnsZone             = os.Getenv("RADIX_DNS_ZONE")
		cluster             = os.Getenv("RADIX_CLUSTER_NAME")
		issuer              = os.Getenv("TOKEN_ISSUER")
		audience            = os.Getenv("TOKEN_AUDIENCE")
		useLocalRadixApi, _ = strconv.ParseBool(os.Getenv("USE_LOCAL_RADIX_API"))
		useProfiler, _      = strconv.ParseBool(os.Getenv("USE_PROFILER"))
		prettyPrint, _      = strconv.ParseBool(os.Getenv("PRETTY_PRINT"))
		logLevel            = os.Getenv("LOG_LEVEL")
	)

	ctx, err := initZerologger(ctx, logLevel, prettyPrint)
	if err != nil {
		errs = append(errs, err)
	}

	if context == "" {
		errs = append(errs, fmt.Errorf("environment variable RADIX_CLUSTER_TYPE is not set"))
	}
	if apiEnv == "" {
		errs = append(errs, fmt.Errorf("environment variable RADIX_ENVIRONMENT is not set"))
	}
	if clusterName == "" {
		errs = append(errs, fmt.Errorf("environment variable RADIX_CLUSTERNAME is not set"))
	}
	if dnsZone == "" {
		errs = append(errs, fmt.Errorf("environment variable RADIX_DNS_ZONE is not set"))
	}
	if issuer == "" {
		errs = append(errs, fmt.Errorf("environment variable TOKEN_ISSUER is not set"))
	}
	if audience == "" {
		errs = append(errs, fmt.Errorf("environment variable TOKEN_AUDIENCE is not set"))
	}

	return &Env{
		Context:          context,
		APIEnvironment:   apiEnv,
		ClusterName:      clusterName,
		DNSZone:          dnsZone,
		Cluster:          cluster,
		UseLocalRadixApi: useLocalRadixApi,
		UseProfiler:      useProfiler,
		OidcAudience:     audience,
		OidcIssuer:       issuer,
		DbCredentials:    getDBCredentials(),
	}, ctx, errors.Join(errs...)
}

func initZerologger(ctx context.Context, logLevel string, prettyPrint bool) (context.Context, error) {
	if logLevel == "" {
		logLevel = "info"
	}

	zerologLevel, err := zerolog.ParseLevel(logLevel)
	if err != nil {
		return nil, err
	}
	zerolog.SetGlobalLevel(zerologLevel)
	zerolog.DurationFieldUnit = time.Millisecond
	if prettyPrint {
		log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.TimeOnly})
	}
	ctx = log.Logger.WithContext(ctx)
	zerolog.DefaultContextLogger = &log.Logger
	return ctx, nil
}

func (env *Env) GetRadixAPIURL() string {
	if env.UseLocalRadixApi {
		return "localhost:3002"
	} else {
		return fmt.Sprintf("server-radix-api-%s.%s.%s", env.APIEnvironment, env.ClusterName, env.DNSZone)
	}
}

func (env *Env) GetRadixAPISchemes() []string {
	if env.UseLocalRadixApi {
		return []string{"http"}
	} else {
		return []string{"https"}
	}
}

func getDBCredentials() *DBCredentials {
	useFederated, _ := strconv.ParseBool(os.Getenv("SQL_USE_FEDERATED"))
	return &DBCredentials{
		Server:       os.Getenv("SQL_SERVER"),
		Database:     os.Getenv("SQL_DATABASE"),
		UserID:       os.Getenv("SQL_USER"),
		Password:     os.Getenv("SQL_PASSWORD"),
		UseFederated: useFederated,
	}
}
