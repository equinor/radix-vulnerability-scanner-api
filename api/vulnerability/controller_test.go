package vulnerability

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"path"
	"testing"

	apiErrors "github.com/equinor/radix-vulnerability-scanner-api/api/errors"
	apiModels "github.com/equinor/radix-vulnerability-scanner-api/api/models"
	handlerMock "github.com/equinor/radix-vulnerability-scanner-api/api/vulnerability/mock"
	"github.com/equinor/radix-vulnerability-scanner-api/models"
	"github.com/equinor/radix-vulnerability-scanner-api/router"
	routerMock "github.com/equinor/radix-vulnerability-scanner-api/router/mock"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/suite"
)

func Test_ControllerTestSuite(t *testing.T) {
	suite.Run(t, new(controllerTestSuite))
}

type controllerTestSuite struct {
	suite.Suite
	handler        *handlerMock.MockHandler
	tokenValidator *routerMock.MockTokenValidator
}

func (s *controllerTestSuite) SetupTest() {
	ctrl := gomock.NewController(s.T())
	s.handler = handlerMock.NewMockHandler(ctrl)
	s.tokenValidator = routerMock.NewMockTokenValidator(ctrl)
}

func (s *controllerTestSuite) Test_GetEnvironmentVulnerabilitySummary() {
	rootPath, appName, envName, token := "/api/any", "anyapp", "anyenv", "anytoken"
	user := &models.User{RawToken: token}
	w := httptest.NewRecorder()
	expected := apiModels.EnvironmentVulnerabilities{Name: "name"}

	s.handler.EXPECT().GetEnvironmentVulnerabilitySummary(gomock.Any(), user, appName, envName).Return(&expected, nil)
	s.tokenValidator.EXPECT().ValidateToken(gomock.Any()).Return(user, nil)

	sut := NewController(s.handler)
	router := router.NewServer("anycluster", rootPath, s.tokenValidator, sut)
	req, _ := http.NewRequest("GET", path.Join(rootPath, fmt.Sprintf("applications/%s/environments/%s", appName, envName)), nil)
	req.Header["Authorization"] = []string{"Bearer " + token}
	router.ServeHTTP(w, req)
	s.Equal(http.StatusOK, w.Code)
	var actual apiModels.EnvironmentVulnerabilities
	s.Require().NoError(json.NewDecoder(w.Body).Decode(&actual))
	s.Equal(expected, actual)
}

func (s *controllerTestSuite) Test_GetEnvironmentVulnerabilitySummary_KnownApiError() {
	rootPath, appName, envName := "/api/any", "anyapp", "anyenv"
	user := &models.User{}
	w := httptest.NewRecorder()

	s.handler.EXPECT().GetEnvironmentVulnerabilitySummary(gomock.Any(), user, appName, envName).Return(nil, apiErrors.ErrNotFound)
	s.tokenValidator.EXPECT().ValidateToken(gomock.Any()).Return(user, nil)

	sut := NewController(s.handler)
	router := router.NewServer("anycluster", rootPath, s.tokenValidator, sut)
	req, _ := http.NewRequest("GET", path.Join(rootPath, fmt.Sprintf("applications/%s/environments/%s", appName, envName)), nil)
	req.Header["Authorization"] = []string{"Bearer anytoken"}
	router.ServeHTTP(w, req)
	s.Equal(http.StatusNotFound, w.Code)
}

func (s *controllerTestSuite) Test_GetComponentVulnerabilities() {
	rootPath, appName, envName, compName, token := "/api/any", "anyapp", "anyenv", "anyComp", "anytoken"
	user := &models.User{RawToken: token}
	w := httptest.NewRecorder()
	expected := apiModels.ImageWithLastScan{Image: apiModels.Image{ImageName: "anyimage"}}

	s.handler.EXPECT().GetComponentVulnerabilities(gomock.Any(), user, appName, envName, compName).Return(&expected, nil)
	s.tokenValidator.EXPECT().ValidateToken(gomock.Any()).Return(user, nil)

	sut := NewController(s.handler)
	router := router.NewServer("anycluster", rootPath, s.tokenValidator, sut)
	req, _ := http.NewRequest("GET", path.Join(rootPath, fmt.Sprintf("applications/%s/environments/%s/components/%s", appName, envName, compName)), nil)
	req.Header["Authorization"] = []string{"Bearer " + token}
	router.ServeHTTP(w, req)
	s.Equal(http.StatusOK, w.Code)
	var actual apiModels.ImageWithLastScan
	s.Require().NoError(json.NewDecoder(w.Body).Decode(&actual))
	s.Equal(expected, actual)
}

func (s *controllerTestSuite) Test_GetComponentVulnerabilities_KnownApiError() {
	rootPath, appName, envName, compName := "/api/any", "anyapp", "anyenv", "anycomp"
	user := &models.User{}
	w := httptest.NewRecorder()

	s.handler.EXPECT().GetComponentVulnerabilities(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, apiErrors.ErrNotFound)
	s.tokenValidator.EXPECT().ValidateToken(gomock.Any()).Return(user, nil)

	sut := NewController(s.handler)
	router := router.NewServer("anycluster", rootPath, s.tokenValidator, sut)
	req, _ := http.NewRequest("GET", path.Join(rootPath, fmt.Sprintf("applications/%s/environments/%s/components/%s", appName, envName, compName)), nil)
	req.Header["Authorization"] = []string{"Bearer anytoken"}
	router.ServeHTTP(w, req)
	s.Equal(http.StatusNotFound, w.Code)
}

func (s *controllerTestSuite) Test_GetJobVulnerabilities() {
	rootPath, appName, envName, compName, token := "/api/any", "anyapp", "anyenv", "anyComp", "anytoken"
	user := &models.User{RawToken: token}
	w := httptest.NewRecorder()
	expected := apiModels.ImageWithLastScan{Image: apiModels.Image{ImageName: "anyimage"}}

	s.handler.EXPECT().GetJobVulnerabilities(gomock.Any(), user, appName, envName, compName).Return(&expected, nil)
	s.tokenValidator.EXPECT().ValidateToken(gomock.Any()).Return(user, nil)

	sut := NewController(s.handler)
	router := router.NewServer("anycluster", rootPath, s.tokenValidator, sut)
	req, _ := http.NewRequest("GET", path.Join(rootPath, fmt.Sprintf("applications/%s/environments/%s/jobs/%s", appName, envName, compName)), nil)
	req.Header["Authorization"] = []string{"Bearer " + token}
	router.ServeHTTP(w, req)
	s.Equal(http.StatusOK, w.Code)
	var actual apiModels.ImageWithLastScan
	s.Require().NoError(json.NewDecoder(w.Body).Decode(&actual))
	s.Equal(expected, actual)
}

func (s *controllerTestSuite) Test_GetJobVulnerabilities_KnownApiError() {
	rootPath, appName, envName, compName := "/api/any", "anyapp", "anyenv", "anycomp"
	user := &models.User{}
	w := httptest.NewRecorder()

	s.handler.EXPECT().GetJobVulnerabilities(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, apiErrors.ErrNotFound)
	s.tokenValidator.EXPECT().ValidateToken(gomock.Any()).Return(user, nil)

	sut := NewController(s.handler)
	router := router.NewServer("anycluster", rootPath, s.tokenValidator, sut)
	req, _ := http.NewRequest("GET", path.Join(rootPath, fmt.Sprintf("applications/%s/environments/%s/jobs/%s", appName, envName, compName)), nil)
	req.Header["Authorization"] = []string{"Bearer anytoken"}
	router.ServeHTTP(w, req)
	s.Equal(http.StatusNotFound, w.Code)
}
