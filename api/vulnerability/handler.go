package vulnerability

import (
	"context"
	"strings"

	apiErrors "github.com/equinor/radix-vulnerability-scanner-api/api/errors"
	apiModels "github.com/equinor/radix-vulnerability-scanner-api/api/models"
	"github.com/equinor/radix-vulnerability-scanner-api/models"
	"github.com/equinor/radix-vulnerability-scanner-api/repository"
	repositoryModels "github.com/equinor/radix-vulnerability-scanner-api/repository/models"
	"github.com/equinor/radix-vulnerability-scanner-api/service"
	serviceModels "github.com/equinor/radix-vulnerability-scanner-api/service/models"
	"github.com/equinor/radix-vulnerability-scanner-api/utils/slice"
)

const (
	componentType = "component"
	jobType       = "job"
)

// vulnerabilityHandler Instance variables
type vulnerabilityHandler struct {
	radixapi service.RadixAPIService
	repo     repository.Interface
}

type VulnerabilityHandler interface {
	GetEnvironmentVulnerabilitySummary(ctx context.Context, user *models.User, appName, envName string) (*apiModels.EnvironmentVulnerabilities, error)
	GetComponentVulnerabilities(ctx context.Context, user *models.User, appName, envName, componentName string) (*apiModels.ImageWithLastScan, error)
	GetJobVulnerabilities(ctx context.Context, user *models.User, appName, envName, jobName string) (*apiModels.ImageWithLastScan, error)
}

// NewHandler Constructor
func NewHandler(radixapi service.RadixAPIService, repo repository.Interface) VulnerabilityHandler {
	return &vulnerabilityHandler{
		radixapi: radixapi,
		repo:     repo,
	}
}

func (h *vulnerabilityHandler) GetEnvironmentVulnerabilitySummary(ctx context.Context, user *models.User, appName, envName string) (*apiModels.EnvironmentVulnerabilities, error) {
	env, err := h.radixapi.GetEnvironment(ctx, appName, envName, user.RawToken)
	if err != nil {
		return nil, err
	}

	components := apiModels.ComponentVulnerabilities{}
	jobs := apiModels.ComponentVulnerabilities{}
	if d := env.ActiveDeployment; d != nil {
		imageNames := slice.Map(env.ActiveDeployment.Components, func(obj serviceModels.Component) string { return obj.Image })
		images, err := h.repo.GetLastImageScan(ctx, imageNames, repository.GetLastImageScanOptions{IncludeVulnerabilityAggregate: true})
		if err != nil {
			return nil, err
		}

		for _, dc := range d.Components {
			scanSummary := apiModels.ImageWithLastScan{Image: apiModels.Image{ImageName: dc.Image}}
			image, found := slice.First(images, func(obj repositoryModels.ImageDto) bool { return strings.EqualFold(dc.Image, obj.Name) })
			if found {
				populateImageWithLastScanFromImageDto(&scanSummary, &image)
			}

			switch dc.Type {
			case componentType:
				components[dc.Name] = scanSummary
			case jobType:
				jobs[dc.Name] = scanSummary
			}
		}
	}

	summary := apiModels.EnvironmentVulnerabilities{
		Name:       env.Name,
		Components: components,
		Jobs:       jobs,
	}

	return &summary, nil
}

func (h *vulnerabilityHandler) GetComponentVulnerabilities(ctx context.Context, user *models.User, appName, envName, componentName string) (*apiModels.ImageWithLastScan, error) {
	return h.getVulnerabilitiesForItem(ctx, user, appName, envName, componentName, componentType)
}

func (h *vulnerabilityHandler) GetJobVulnerabilities(ctx context.Context, user *models.User, appName, envName, jobName string) (*apiModels.ImageWithLastScan, error) {
	return h.getVulnerabilitiesForItem(ctx, user, appName, envName, jobName, jobType)
}

func (h *vulnerabilityHandler) getVulnerabilitiesForItem(ctx context.Context, user *models.User, appName, envName, itemName, itemType string) (*apiModels.ImageWithLastScan, error) {
	var scanDetails apiModels.ImageWithLastScan
	env, err := h.radixapi.GetEnvironment(ctx, appName, envName, user.RawToken)
	if err != nil {
		return nil, err
	}

	if d := env.ActiveDeployment; d != nil {
		dc, found := slice.First(d.Components, func(obj serviceModels.Component) bool {
			return strings.EqualFold(obj.Name, itemName) && strings.EqualFold(obj.Type, itemType)
		})
		if found {
			images, err := h.repo.GetLastImageScan(ctx, []string{dc.Image}, repository.GetLastImageScanOptions{IncludeVulnerabilityAggregate: true, IncludeVulnerabilities: true})
			if err != nil {
				return nil, err
			}

			image, found := slice.First(images, func(obj repositoryModels.ImageDto) bool { return strings.EqualFold(dc.Image, obj.Name) })
			if found {
				populateImageWithLastScanFromImageDto(&scanDetails, &image)
			}
		} else {
			return nil, apiErrors.ErrNotFound
		}
	} else {
		return nil, apiErrors.ErrNotFound
	}

	return &scanDetails, nil
}

func populateImageWithLastScanFromImageDto(target *apiModels.ImageWithLastScan, source *repositoryModels.ImageDto) {
	if target == nil || source == nil {
		return
	}

	target.ImageName = source.Name
	target.BaseImage = source.BaseImage

	if len(source.Scans) > 0 {
		sortedScansDesc := slice.OrderBy(source.Scans, func(first, second repositoryModels.ImageScanDto) bool { return first.ScanTime.After(second.ScanTime) })
		lastScan, _ := slice.First(sortedScansDesc)

		imageScan := apiModels.ImageScan{
			ScanTime:             lastScan.ScanTime,
			ScanSuccess:          lastScan.ScanSuccess,
			VulnerabilitySummary: make(map[string]int),
			Vulnerabilities:      make([]apiModels.Vulnerability, 0, len(lastScan.Vulnerabilities)),
		}

		if len(lastScan.VulnerabilityAggregation) > 0 {
			for _, agg := range lastScan.VulnerabilityAggregation {
				imageScan.VulnerabilitySummary[agg.Severity] = agg.Count
			}
		}

		for _, vulnDto := range lastScan.Vulnerabilities {
			var vuln apiModels.Vulnerability
			vuln.FromDto(&vulnDto)
			imageScan.Vulnerabilities = append(imageScan.Vulnerabilities, vuln)
		}

		target.ImageScan = &imageScan
	}
}
