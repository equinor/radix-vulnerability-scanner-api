package vulnerability

import (
	"context"
	"strings"

	apiErrors "github.com/equinor/radix-vulnerability-scanner-api/api/errors"
	apiModels "github.com/equinor/radix-vulnerability-scanner-api/api/models"
	"github.com/equinor/radix-vulnerability-scanner-api/models"
	"github.com/equinor/radix-vulnerability-scanner-api/repository"
	repositoryModels "github.com/equinor/radix-vulnerability-scanner-api/repository/models"
	"github.com/equinor/radix-vulnerability-scanner-api/service"
	serviceModels "github.com/equinor/radix-vulnerability-scanner-api/service/models"
	"github.com/equinor/radix-vulnerability-scanner-api/utils/slice"
)

// VulnerabilityHandler Instance variables
type VulnerabilityHandler struct {
	user     *models.User
	radixapi service.RadixAPIService
	repo     repository.Repository
}

// NewVulnerabilityHandler Constructor
func NewVulnerabilityHandler(user *models.User, radixapi service.RadixAPIService, repo repository.Repository) VulnerabilityHandler {
	return VulnerabilityHandler{
		user:     user,
		radixapi: radixapi,
		repo:     repo,
	}
}

func (h *VulnerabilityHandler) GetEnvironmentVulnerabilitySummary(ctx context.Context, appName, envName string) (*apiModels.EnvironmentVulnerabilities, error) {
	env, err := h.radixapi.GetEnvironment(ctx, appName, envName, h.user.RawToken)
	if err != nil {
		return nil, err
	}

	components := apiModels.ComponentVulnerabilities{}
	jobs := apiModels.ComponentVulnerabilities{}
	if d := env.ActiveDeployment; d != nil {
		imageNames := slice.Map(env.ActiveDeployment.Components, func(obj serviceModels.Component) string { return obj.Image })
		images, err := h.repo.GetLastImageScan(ctx, imageNames, repository.GetLastImageScanOptions{IncludeVulnerabilityAggregate: true})
		if err != nil {
			return nil, err
		}

		for _, dc := range d.Components {
			scanSummary := apiModels.ImageWithLastScan{Image: apiModels.Image{ImageName: dc.Image}}
			image, found := slice.First(images, func(obj repositoryModels.ImageDto) bool { return strings.EqualFold(dc.Image, obj.Name) })
			if found {
				populateImageWithLastScanFromImageDto(&scanSummary, &image)
			}

			switch dc.Type {
			case "component":
				components[dc.Name] = scanSummary
			case "job":
				jobs[dc.Name] = scanSummary
			}
		}
	}

	summary := apiModels.EnvironmentVulnerabilities{
		Name:       env.Name,
		Components: components,
		Jobs:       jobs,
	}

	return &summary, nil
}

func (h *VulnerabilityHandler) GetComponentVulnerabilities(ctx context.Context, appName, envName, componentName string) (*apiModels.ImageWithLastScan, error) {
	return h.getVulnerabilitiesForItem(ctx, appName, envName, componentName, "component")
}

func (h *VulnerabilityHandler) GetJobVulnerabilities(ctx context.Context, appName, envName, jobName string) (*apiModels.ImageWithLastScan, error) {
	return h.getVulnerabilitiesForItem(ctx, appName, envName, jobName, "job")
}

func (h *VulnerabilityHandler) getVulnerabilitiesForItem(ctx context.Context, appName, envName, itemName, itemType string) (*apiModels.ImageWithLastScan, error) {
	var scanDetails apiModels.ImageWithLastScan
	env, err := h.radixapi.GetEnvironment(ctx, appName, envName, h.user.RawToken)
	if err != nil {
		return nil, err
	}

	if d := env.ActiveDeployment; d != nil {
		dc, found := slice.First(d.Components, func(obj serviceModels.Component) bool {
			return strings.EqualFold(obj.Name, itemName) && strings.EqualFold(obj.Type, itemType)
		})
		if found {
			images, err := h.repo.GetLastImageScan(ctx, []string{dc.Image}, repository.GetLastImageScanOptions{IncludeVulnerabilityAggregate: true, IncludeVulnerabilities: true})
			if err != nil {
				return nil, err
			}

			image, found := slice.First(images, func(obj repositoryModels.ImageDto) bool { return strings.EqualFold(dc.Image, obj.Name) })
			if found {
				populateImageWithLastScanFromImageDto(&scanDetails, &image)
			}
		} else {
			return nil, apiErrors.ErrNotFound
		}
	} else {
		return nil, apiErrors.ErrNotFound
	}

	return &scanDetails, nil
}

func populateImageWithLastScanFromImageDto(target *apiModels.ImageWithLastScan, source *repositoryModels.ImageDto) {
	if target == nil || source == nil {
		return
	}

	target.ImageName = source.Name
	target.BaseImage = source.BaseImage

	if len(source.Scans) > 0 {
		sortedScansDesc := slice.OrderBy(source.Scans, func(first, second repositoryModels.ImageScanDto) bool { return first.ScanTime.After(second.ScanTime) })
		lastScan, _ := slice.First(sortedScansDesc)

		imageScan := apiModels.ImageScan{
			ScanTime:    lastScan.ScanTime,
			ScanSuccess: lastScan.ScanSuccess,
		}

		if len(lastScan.VulnerabilityAggregation) > 0 {
			imageScan.VulnerabilitySummary = make(map[string]int)

			for _, agg := range lastScan.VulnerabilityAggregation {
				imageScan.VulnerabilitySummary[agg.Severity] = agg.Count
			}
		}

		target.ImageScan = &imageScan
	}
}
