package vulnerability

import (
	"context"
	"strings"

	apiErrors "github.com/equinor/radix-vulnerability-scanner-api/api/errors"
	apiModels "github.com/equinor/radix-vulnerability-scanner-api/api/models"
	"github.com/equinor/radix-vulnerability-scanner-api/models"
	"github.com/equinor/radix-vulnerability-scanner-api/repository"
	repositoryModels "github.com/equinor/radix-vulnerability-scanner-api/repository/models"
	"github.com/equinor/radix-vulnerability-scanner-api/service"
	serviceModels "github.com/equinor/radix-vulnerability-scanner-api/service/models"
	"github.com/equinor/radix-vulnerability-scanner-api/utils/slice"
	"golang.org/x/sync/errgroup"
)

const (
	componentType = "component"
	jobType       = "job"
)

// handler Instance variables
type handler struct {
	radixapi service.RadixAPIService
	repo     repository.Interface
}

type Handler interface {
	GetApplicationVulnerabilitySummaries(ctx context.Context, user *models.User, appName string) ([]*apiModels.EnvironmentVulnerabilities, error)
	GetApplicationsVulnerabilitySummaries(ctx context.Context, user *models.User, appNames []string) (map[string][]*apiModels.EnvironmentVulnerabilities, error)
	GetEnvironmentVulnerabilitySummary(ctx context.Context, user *models.User, appName, envName string) (*apiModels.EnvironmentVulnerabilities, error)
	GetComponentVulnerabilities(ctx context.Context, user *models.User, appName, envName, componentName string) (*apiModels.ImageWithLastScan, error)
	GetJobVulnerabilities(ctx context.Context, user *models.User, appName, envName, jobName string) (*apiModels.ImageWithLastScan, error)
}

// NewHandler Constructor
func NewHandler(radixapi service.RadixAPIService, repo repository.Interface) Handler {
	return &handler{
		radixapi: radixapi,
		repo:     repo,
	}
}

func (h *handler) GetApplicationVulnerabilitySummaries(ctx context.Context, user *models.User, appName string) ([]*apiModels.EnvironmentVulnerabilities, error) {
	envSummaries, err := h.radixapi.GetEnvironmentSummaries(ctx, user.RawToken, appName)
	if err != nil {
		return nil, err
	}

	var g errgroup.Group
	g.SetLimit(5)

	sumChan := make(chan *apiModels.EnvironmentVulnerabilities, len(envSummaries))
	for _, envSummary := range envSummaries {
		summary := envSummary
		g.Go(func() error {
			var components []serviceModels.ComponentSummary
			if summary.ActiveDeployment != nil {
				components = summary.ActiveDeployment.Components
			}

			sum, err := h.getEnvironmentVulnerabilitySummary(ctx, user, summary.Name, components)
			if err == nil {
				sumChan <- sum
			}
			return err
		})
	}

	err = g.Wait()
	close(sumChan)
	if err != nil {
		return nil, err
	}

	var summaries []*apiModels.EnvironmentVulnerabilities
	for sum := range sumChan {
		summaries = append(summaries, sum)
	}

	return summaries, nil
}

func (h *handler) GetApplicationsVulnerabilitySummaries(ctx context.Context, user *models.User, appNames []string) (map[string][]*apiModels.EnvironmentVulnerabilities, error) {
	type ChannelData struct {
		appName   string
		summaries []*apiModels.EnvironmentVulnerabilities
	}

	var g errgroup.Group
	g.SetLimit(10)

	sumsChan := make(chan *ChannelData, len(appNames))
	for _, appName := range appNames {
		appName := appName
		g.Go(func() error {
			sums, err := h.GetApplicationVulnerabilitySummaries(ctx, user, appName)
			if err == nil {
				sumsChan <- &ChannelData{appName: appName, summaries: sums}
			}
			return err
		})
	}

	err := g.Wait()
	close(sumsChan)
	if err != nil {
		return nil, err
	}

	summaries := make(map[string][]*apiModels.EnvironmentVulnerabilities)
	for sums := range sumsChan {
		summaries[sums.appName] = sums.summaries
	}

	return summaries, nil
}

func (h *handler) GetEnvironmentVulnerabilitySummary(ctx context.Context, user *models.User, appName, envName string) (*apiModels.EnvironmentVulnerabilities, error) {
	env, err := h.radixapi.GetEnvironment(ctx, user.RawToken, appName, envName)
	if err != nil {
		return nil, err
	}

	var components []serviceModels.Component
	if env.ActiveDeployment != nil {
		components = env.ActiveDeployment.Components
	}

	summaries := slice.Map(components, func(obj serviceModels.Component) serviceModels.ComponentSummary {
		return serviceModels.ComponentSummary(obj)
	})
	return h.getEnvironmentVulnerabilitySummary(ctx, user, env.Name, summaries)
}

func (h *handler) GetComponentVulnerabilities(ctx context.Context, user *models.User, appName, envName, componentName string) (*apiModels.ImageWithLastScan, error) {
	return h.getVulnerabilitiesForItem(ctx, user, appName, envName, componentName, componentType)
}

func (h *handler) GetJobVulnerabilities(ctx context.Context, user *models.User, appName, envName, jobName string) (*apiModels.ImageWithLastScan, error) {
	return h.getVulnerabilitiesForItem(ctx, user, appName, envName, jobName, jobType)
}

func (h *handler) getEnvironmentVulnerabilitySummary(ctx context.Context, user *models.User, envName string, componentSummaries []serviceModels.ComponentSummary) (*apiModels.EnvironmentVulnerabilities, error) {
	components := apiModels.ComponentVulnerabilities{}
	jobs := apiModels.ComponentVulnerabilities{}
	if len(componentSummaries) > 0 {
		imageNames := slice.Map(componentSummaries, func(obj serviceModels.ComponentSummary) string { return obj.Image })
		images, err := h.repo.GetLastImageScan(ctx, imageNames, repository.GetLastImageScanOptions{IncludeVulnerabilityAggregate: true})
		if err != nil {
			return nil, err
		}

		for _, component := range componentSummaries {
			scanSummary := apiModels.ImageWithLastScan{Image: apiModels.Image{ImageName: component.Image}}
			image, found := slice.First(images, func(obj repositoryModels.ImageDto) bool { return strings.EqualFold(component.Image, obj.Name) })
			if found {
				populateImageWithLastScanFromImageDto(&scanSummary, &image)
			}

			switch component.Type {
			case componentType:
				components[component.Name] = scanSummary
			case jobType:
				jobs[component.Name] = scanSummary
			}
		}
	}

	summary := apiModels.EnvironmentVulnerabilities{
		Name:       envName,
		Components: components,
		Jobs:       jobs,
	}
	return &summary, nil
}

func (h *handler) getVulnerabilitiesForItem(ctx context.Context, user *models.User, appName, envName, itemName, itemType string) (*apiModels.ImageWithLastScan, error) {
	env, err := h.radixapi.GetEnvironment(ctx, user.RawToken, appName, envName)
	if err != nil {
		return nil, err
	} else if env.ActiveDeployment == nil {
		return nil, apiErrors.ErrNotFound
	}

	component, found := slice.First(env.ActiveDeployment.Components, func(obj serviceModels.Component) bool {
		return strings.EqualFold(obj.Name, itemName) && strings.EqualFold(obj.Type, itemType)
	})
	if !found {
		return nil, apiErrors.ErrNotFound
	}

	images, err := h.repo.GetLastImageScan(ctx, []string{component.Image}, repository.GetLastImageScanOptions{IncludeVulnerabilityAggregate: true, IncludeVulnerabilities: true})
	if err != nil {
		return nil, err
	}

	var scanDetails apiModels.ImageWithLastScan
	scanDetails.ImageName = component.Image
	image, found := slice.First(images, func(obj repositoryModels.ImageDto) bool { return strings.EqualFold(component.Image, obj.Name) })
	if found {
		populateImageWithLastScanFromImageDto(&scanDetails, &image)
	}

	return &scanDetails, nil
}

func populateImageWithLastScanFromImageDto(target *apiModels.ImageWithLastScan, source *repositoryModels.ImageDto) {
	if target == nil || source == nil {
		return
	}

	target.BaseImage = source.BaseImage

	if len(source.Scans) > 0 {
		sortedScansDesc := slice.OrderBy(source.Scans, func(first, second repositoryModels.ImageScanDto) bool { return first.ScanTime.After(second.ScanTime) })
		lastScan, _ := slice.First(sortedScansDesc)

		imageScan := apiModels.ImageScan{
			ScanTime:             lastScan.ScanTime,
			ScanSuccess:          lastScan.ScanSuccess,
			VulnerabilitySummary: make(map[string]int),
			Vulnerabilities:      make([]apiModels.Vulnerability, 0, len(lastScan.Vulnerabilities)),
		}

		if len(lastScan.VulnerabilityAggregation) > 0 {
			for _, agg := range lastScan.VulnerabilityAggregation {
				imageScan.VulnerabilitySummary[agg.Severity] = agg.Count
			}
		}

		for _, vulnDto := range lastScan.Vulnerabilities {
			var vuln apiModels.Vulnerability
			vuln.FromDto(&vulnDto)
			imageScan.Vulnerabilities = append(imageScan.Vulnerabilities, vuln)
		}

		target.ImageScan = &imageScan
	}
}
