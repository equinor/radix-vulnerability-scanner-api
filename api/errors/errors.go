package errors

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/rs/zerolog/log"
)

var (
	ErrUnauthorized        = &apiError{status: http.StatusUnauthorized, msg: "invalid token"}
	ErrNotFound            = &apiError{status: http.StatusNotFound, msg: "not found"}
	ErrBadRequest          = &apiError{status: http.StatusBadRequest, msg: "bad request"}
	ErrInternalServerError = &apiError{status: http.StatusInternalServerError, msg: "internal server error"}
)

type APIError interface {
	APIError() (int, string)
}

type apiError struct {
	status int
	msg    string
}

func (e apiError) Error() string {
	return e.msg
}

func (e apiError) APIError() (int, string) {
	return e.status, e.msg
}

type wrappedApiError struct {
	error
	apiError *apiError
}

func (e wrappedApiError) Is(err error) bool {
	return e.apiError == err
}

func (e wrappedApiError) APIError() (int, string) {
	return e.apiError.APIError()
}

func WrapError(err error, apiError *apiError) error {
	return wrappedApiError{error: err, apiError: apiError}
}

func HandleErrorJSON(c *gin.Context, err error) {
	var apiErr APIError

	log.Error().Msg(err.Error())

	if !errors.As(err, &apiErr) {
		apiErr = ErrInternalServerError
	}

	code, msg := apiErr.APIError()
	writeJSONError(c, code, msg)

	c.Abort()
}

func writeJSONError(c *gin.Context, code int, msg string) {
	c.JSON(code, gin.H{
		"code":    code,
		"message": msg,
	})
}
